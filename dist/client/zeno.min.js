var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const p = "" + new URL("zeno_worker.js", import.meta.url).href;
class f extends EventTarget {
  constructor(e) {
    super();
    __publicField(this, "worker");
    __publicField(this, "config");
    __publicField(this, "_token", null);
    this.config = e, console.debug("Zeno Lib Initialized");
    const o = typeof window < "u" && (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1");
    let t;
    p.includes("worker") || p.endsWith(".ts") ? t = p : o ? t = "zeno_worker.js" : t = import.meta.url.replace(/zeno(\.min)?\.js(\?.*)?$/, "zeno_worker.js"), console.log("Zeno Worker Source:", t);
    const n = `import "${t}";`, r = new Blob([n], { type: "application/javascript" }), i = URL.createObjectURL(r);
    this.worker = new Worker(i, {
      type: "module"
    });
  }
  get token() {
    return this._token;
  }
  async solve() {
    const e = await this.fetchChallenge(), o = await this.solveInWorker(e), t = await this.redeem(e.challenge_id, o);
    return this._token = t, this.dispatchEvent(new CustomEvent("solve", { detail: { token: t } })), { token: t };
  }
  terminate() {
    this.worker && this.worker.terminate();
  }
  async fetchChallenge() {
    const e = await this.customFetch(`${this.config.apiEndpoint}/challenge`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        site_key: this.config.siteKey
      })
    });
    if (!e.ok)
      throw new Error(`Challenge fetch failed: ${e.statusText}`);
    return await e.json();
  }
  async redeem(e, o) {
    const t = {
      challenge_id: e,
      solution: o,
      site_key: this.config.siteKey
    }, n = await this.customFetch(`${this.config.apiEndpoint}/redeem`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(t)
    });
    if (!n.ok)
      throw new Error(`Redeem failed: ${n.statusText}`);
    return (await n.json()).token;
  }
  async solveInWorker(e) {
    return new Promise((o, t) => {
      const n = (s) => {
        const { type: a, payload: l, error: d } = s.data;
        this.worker.removeEventListener("message", n), this.worker.removeEventListener("error", r), a === "SOLVED" ? (l.memoryUsage = s.data.memory, o(l)) : a === "ERROR" && t(new Error(d));
      }, r = (s) => {
        this.worker.removeEventListener("message", n), this.worker.removeEventListener("error", r), t(new Error(`Worker Error: ${s.message}`));
      };
      this.worker.addEventListener("message", n), this.worker.addEventListener("error", r);
      let i = "";
      if (window.ZENO_WASM_URL)
        i = window.ZENO_WASM_URL;
      else if (import.meta.url) {
        if (i = import.meta.url.replace(/zeno(\.min)?\.js(\?.*)?$/, "zeno.wasm"), i === import.meta.url)
          try {
            i = new URL("zeno.wasm", self.location).href;
          } catch {
            try {
              i = new URL("/zeno.wasm", window.location.href).href;
            } catch {
              i = "zeno.wasm";
            }
          }
      } else
        try {
          i = new URL("/zeno.wasm", window.location.href).href;
        } catch {
          i = "zeno.wasm";
        }
      this.worker.postMessage({ type: "SOLVE", challenge: e, wasm_url: i });
    });
  }
  customFetch(e, o = {}) {
    return window.ZENO_CUSTOM_FETCH ? window.ZENO_CUSTOM_FETCH(e, o) : fetch(e, o);
  }
}
const b = `
<style>
:host {
    display: inline-block;
    --zeno-background: #fdfdfd;
    --zeno-border-color: #dddddd8f;
    --zeno-border-radius: 14px;
    --zeno-widget-height: 50px;
    --zeno-widget-width: 250px; /* Slightly larger default to fit content */
    --zeno-widget-padding: 10px;
    --zeno-color: #212121;
    --zeno-font: system-ui, -apple-system, sans-serif;
    --zeno-checkbox-size: 24px;
    --zeno-checkbox-border: 1px solid #aaaaaad1;
    --zeno-checkbox-border-radius: 6px;
    --zeno-checkbox-background: #fafafa91;
    --zeno-spinner-color: #000;
}

.container {
    background: var(--zeno-background);
    border: 1px solid var(--zeno-border-color);
    border-radius: var(--zeno-border-radius);
    width: var(--zeno-widget-width);
    height: var(--zeno-widget-height);
    padding: var(--zeno-widget-padding);
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: var(--zeno-font);
    color: var(--zeno-color);
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    transition: all 0.2s ease;
    cursor: pointer;
    user-select: none;
}

.checkbox {
    width: var(--zeno-checkbox-size);
    height: var(--zeno-checkbox-size);
    border: var(--zeno-checkbox-border);
    border-radius: var(--zeno-checkbox-border-radius);
    background: var(--zeno-checkbox-background);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.spinner {
    display: none;
    width: 60%;
    height: 60%;
    border: 2px solid #ccc;
    border-top-color: var(--zeno-spinner-color);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

.checkmark {
    display: none;
    color: #4CAF50; /* Fallback green */
    font-size: 18px;
    font-weight: bold;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.label {
    font-size: 14px;
    font-weight: 500;
}

/* States */
.container.verifying .spinner { display: block; }
.container.verified .checkmark { display: block; }
.container.verified .checkbox { border-color: transparent; }

/* Accessible Hidden Input */
    display: none;
}

.footer {
    position: absolute;
    bottom: 2px;
    bottom: 2px;
    right: 12px; /* Sufficient padding from border */
    font-size: 10px;
    color: var(--zeno-color) !important;
    text-decoration: underline;
    opacity: 0.6;
    pointer-events: all;
    transform: scale(0.6);
    transform-origin: bottom right;
    transition: color 0.2s;
}
a.footer, a.footer:visited, a.footer:hover, a.footer:active {
    color: var(--zeno-color) !important;
}
.footer * {
    color: var(--zeno-color) !important;
}
.footer:hover {
    opacity: 1;
}
</style>
<div class="container" id="box" tabindex="0" role="checkbox" aria-checked="false" style="position: relative;">
    <div class="checkbox">
        <div class="spinner"></div>
        <div class="checkmark">\u2713</div>
    </div>
    <div class="label" id="text">I am human</div>
    <a href="https://github.com/zeno-security/zeno" target="_blank" class="footer" style="position: absolute; bottom: 2px; right: 12px; transform: scale(0.6); transform-origin: bottom right; color: var(--zeno-color) !important; text-decoration: underline;">Zeno</a>
</div>
`;
class g extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "zeno", null);
    __publicField(this, "shadow");
    __publicField(this, "container", null);
    __publicField(this, "label", null);
    __publicField(this, "isSolving", false);
    __publicField(this, "isSolved", false);
    this.shadow = this.attachShadow({ mode: "open" }), this.shadow.innerHTML = b;
  }
  static get observedAttributes() {
    return ["zeno-api-endpoint", "zeno-floating", "zeno-site-key", "zeno-i18n-human-label"];
  }
  connectedCallback() {
    var _a, _b;
    this.container = this.shadow.getElementById("box"), this.label = this.shadow.getElementById("text"), (_a = this.container) == null ? void 0 : _a.addEventListener("click", () => this.startVerification()), (_b = this.container) == null ? void 0 : _b.addEventListener("keydown", (o) => {
      (o.key === "Enter" || o.key === " ") && (o.preventDefault(), this.startVerification());
    }), this.setupFloating(), setTimeout(() => this.updateFooterContrast(), 0), this.updateHumanLabel(), new MutationObserver(() => this.updateFooterContrast()).observe(this, { attributes: true, attributeFilter: ["style"] });
  }
  attributeChangedCallback(e, o, t) {
    e === "zeno-i18n-human-label" && this.updateHumanLabel();
  }
  updateHumanLabel() {
    this.label && !this.isSolving && !this.isSolved && (this.label.innerText = this.getAttribute("zeno-i18n-human-label") || "I am human");
  }
  updateFooterContrast() {
    const e = getComputedStyle(this).getPropertyValue("--zeno-background").trim(), o = this.getContrastColor(e), t = this.shadow.querySelector(".footer");
    t && (t.style.setProperty("color", o, "important"), t.style.setProperty("text-decoration-color", o, "important"));
  }
  getContrastColor(e) {
    if (!e || !e.startsWith("#"))
      return "#000000";
    const o = parseInt(e.substr(1, 2), 16), t = parseInt(e.substr(3, 2), 16), n = parseInt(e.substr(5, 2), 16), r = (u) => {
      const h = u / 255;
      return h <= 0.03928 ? h / 12.92 : Math.pow((h + 0.055) / 1.055, 2.4);
    }, i = 0.2126 * r(o) + 0.7152 * r(t) + 0.0722 * r(n), s = 1, a = 0, l = (s + 0.05) / (i + 0.05), d = (i + 0.05) / (a + 0.05);
    return l > d ? "#ffffff" : "#000000";
  }
  setupFloating() {
  }
  async startVerification() {
    var _a, _b;
    if (this.updateFooterContrast(), this.isSolving || this.isSolved)
      return;
    const e = this.getAttribute("zeno-api-endpoint"), o = this.getAttribute("zeno-site-key");
    if (!e) {
      console.error("Zeno: Missing 'zeno-api-endpoint' attribute"), this.setLabel("Config Error");
      return;
    }
    if (!o) {
      console.error("Zeno: Missing 'zeno-site-key' attribute"), this.setLabel("Config Error");
      return;
    }
    this.isSolving = true, (_a = this.container) == null ? void 0 : _a.classList.add("verifying"), this.setLabel(this.getAttribute("zeno-i18n-verifying-label") || "Verifying...");
    try {
      this.zeno = new f({ apiEndpoint: e, siteKey: o });
      const { token: t } = await this.zeno.solve();
      this.handleSuccess(t);
    } catch (t) {
      console.error("Zeno Error:", t), this.setLabel(this.getAttribute("zeno-i18n-error-label") || "Error"), (_b = this.container) == null ? void 0 : _b.classList.remove("verifying"), this.isSolving = false, this.dispatchEvent(new CustomEvent("error", { detail: { message: t.toString() } }));
    }
  }
  handleSuccess(e) {
    var _a, _b, _c;
    this.isSolved = true, this.isSolving = false, (_a = this.container) == null ? void 0 : _a.classList.remove("verifying"), (_b = this.container) == null ? void 0 : _b.classList.add("verified"), this.setLabel(this.getAttribute("zeno-i18n-solved-label") || "Success!"), (_c = this.container) == null ? void 0 : _c.setAttribute("aria-checked", "true");
    const o = this.getAttribute("data-zeno-hidden-field-name") || "zeno-token";
    let t = this.querySelector(`input[name="${o}"]`);
    t || (t = document.createElement("input"), t.type = "hidden", t.name = o, this.appendChild(t)), t.value = e, this.dispatchEvent(new CustomEvent("solve", {
      detail: { token: e },
      bubbles: true,
      composed: true
    }));
    const n = this.getAttribute("onsolve");
    n && new Function("event", n)(new CustomEvent("solve", { detail: { token: e } }));
  }
  setLabel(e) {
    this.label && (this.label.innerText = e);
  }
}
customElements.define("zeno-widget", g);
document.addEventListener("click", (c) => {
  const e = c.target.closest("[zeno-floating]");
  if (e) {
    const o = e.getAttribute("zeno-floating");
    if (o) {
      const t = document.querySelector(o);
      if (t) {
        const n = t.style.display === "none";
        if (t.style.display = n ? "inline-block" : "none", n) {
          const r = e.getBoundingClientRect(), i = e.getAttribute("zeno-floating-position") || "bottom", s = parseInt(e.getAttribute("zeno-floating-offset") || "10");
          t.style.position = "absolute", t.style.zIndex = "9999", i === "bottom" && (t.style.top = `${r.bottom + window.scrollY + s}px`, t.style.left = `${r.left + window.scrollX}px`);
        }
      }
    }
  }
});
export {
  f as Zeno
};
