<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Zeno Benchmark</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 20px;
            background: #f5f5f7;
            color: #1d1d1f;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        p {
            color: #86868b;
            margin-bottom: 20px;
        }

        button {
            background: #0071e3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #0077ed;
        }

        button:disabled {
            background: #999;
            cursor: default;
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .status-container {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-grow: 1;
            justify-content: flex-end;
        }

        #status {
            font-weight: 500;
            color: #1d1d1f;
        }

        #advancedBtn {
            font-size: 14px;
            color: #1d1d1f;
            text-decoration: none;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 1px dotted #1d1d1f;
        }

        #advancedBtn:hover {
            opacity: 0.7;
        }

        #log {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: "SF Mono", Monaco, Consolas, monospace;
            font-size: 12px;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            text-align: left;
            padding: 12px 15px;
            border-bottom: 1px solid #e5e5ea;
        }

        th {
            background: #f5f5f7;
            font-weight: 600;
            font-size: 12px;
            color: #86868b;
            text-transform: uppercase;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .fail {
            color: #d70015;
        }

        .header-row {
            background: #e8f0fe;
            font-weight: bold;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal {
            background: white;
            padding: 24px;
            border-radius: 12px;
            width: 500px;
            max-width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        }

        .modal h2 {
            margin-top: 0;
            font-size: 18px;
            margin-bottom: 16px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .modal-section {
            margin-bottom: 16px;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 12px;
        }

        .modal-section:last-child {
            border-bottom: none;
        }

        .modal-section h3 {
            font-size: 14px;
            margin: 0 0 8px 0;
            color: #0071e3;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .setting-row label {
            flex: 1;
        }

        .setting-row input[type="number"] {
            width: 70px;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .setting-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .btn-secondary {
            background: #e5e5ea;
            color: #1d1d1f;
        }

        .btn-secondary:hover {
            background: #d2d2d7;
        }

        .indent {
            padding-left: 24px;
        }

        .space-top {
            padding-top: 8px;
        }

        .input-sm {
            width: 50px;
        }
    </style>
</head>

<body>
    <h1>Zeno Benchmark</h1>

    <div class="controls">
        <button type="button" id="startBtn">START</button>
        <div class="status-container">
            <div id="status">Ready</div>
            <a href="#" id="advancedBtn">ADVANCED</a>
        </div>
    </div>

    <div id="log"></div>

    <table id="results">
        <thead>
            <tr>
                <th>Test / Round</th>
                <th>Mode</th>
                <th>Graph Bits</th>
                <th>VDF</th>
                <th>Time (ms)</th>
                <th>Memory (MB)</th>
                <th>Status</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <!-- Advanced Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal" id="modalContent">
            <h2>Advanced Settings</h2>

            <div class="modal-section">
                <h3>Test Mode</h3>
                <div class="setting-row">
                    <label><input type="radio" name="cfg_mode" value="both" checked> <strong>WASM + JS
                            (Default)</strong></label>
                </div>
                <div class="setting-row">
                    <label><input type="radio" name="cfg_mode" value="wasm"> <strong>WASM Only</strong></label>
                </div>
                <div class="setting-row">
                    <label><input type="radio" name="cfg_mode" value="js"> <strong>JS Only</strong></label>
                </div>
            </div>

            <div class="modal-section">
                <h3>Global Stop Criteria</h3>
                <div class="setting-row">
                    <label>Max Time (ms)</label>
                    <input type="number" id="cfg_max_time">
                </div>
                <div class="setting-row">
                    <label>Max Memory (MB)</label>
                    <input type="number" id="cfg_max_mem">
                </div>
            </div>

            <div class="modal-section">
                <h3>Test Selection &amp; Params</h3>

                <div class="setting-row">
                    <label><input type="checkbox" id="cfg_sanity"> <strong>Sanity Check</strong></label>
                </div>

                <div class="setting-row">
                    <label><input type="checkbox" id="cfg_r1"> <strong>R1: Graph Ramp</strong></label>
                </div>
                <div class="setting-row indent">
                    Start GB: <input type="number" id="cfg_r1_start" class="input-sm">
                    Iter/Step: <input type="number" id="cfg_r1_step" class="input-sm">
                </div>

                <div class="setting-row space-top">
                    <label><input type="checkbox" id="cfg_r2"> <strong>R2: VDF Ramp</strong></label>
                </div>
                <div class="setting-row indent">
                    Start VDF: <input type="number" id="cfg_r2_start" class="input-sm">
                    Iter/Step: <input type="number" id="cfg_r2_step" class="input-sm">
                </div>

                <div class="setting-row space-top">
                    <label><input type="checkbox" id="cfg_r3"> <strong>R3: Combinations</strong></label>
                </div>
                <div class="setting-row indent">
                    <em>Iterates all Valid Graphs from R1 with:</em>
                </div>
                <div class="setting-row indent">
                    Start VDF: <input type="number" id="cfg_r3_v_start" class="input-sm">
                    Iter/Step: <input type="number" id="cfg_r3_v_step" class="input-sm">
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn-secondary" id="resetBtn">Reset to Defaults</button>
                <button type="button" id="saveBtn">Save &amp; Close</button>
            </div>
        </div>
    </div>

    <!-- Zeno Worker Script -->
    <script type="module">
        import { Zeno as ZenoBase } from 'https://cdn.jsdelivr.net/gh/zeno-security/zeno/dist/client/zeno.min.js';

        // Wrapper to track worker for terminate support
        class Zeno extends ZenoBase {
            constructor(opts) {
                super(opts);
                this._worker = null;
            }

            async solveInWorker(challenge) {
                // Intercept to capture worker reference
                const result = await super.solveInWorker(challenge);
                // Worker is created internally - we can't easily access it
                // But we can track if we need a fresh instance
                return result;
            }

            terminate() {
                // Force recreation on next solve by nulling instance state
                // The actual worker cleanup happens when it's garbage collected
                // or when a new worker replaces it
                this._terminated = true;
            }

            get isTerminated() {
                return this._terminated === true;
            }
        }

        // --- Config State (defaults per screenshot) ---
        const DEFAULT_CONFIG = {
            mode: 'both', // 'both', 'wasm', 'js'
            limits: { time: 1500, mem: 320 },
            tests: { sanity: true, r1: true, r2: true, r3: true },
            r1: { start: 11, step: 1 },
            r2: { start: 100, step: 100 },
            r3: { vStart: 100, vStep: 50 }
        };

        // Deep copy for current config
        let CONFIG = JSON.parse(JSON.stringify(DEFAULT_CONFIG));

        const logEl = document.getElementById('log');
        const statusEl = document.getElementById('status');
        const tableBody = document.getElementById('results').querySelector('tbody');
        const startBtn = document.getElementById('startBtn');

        // Modal UI Elements
        const modal = document.getElementById('settingsModal');
        const advancedBtn = document.getElementById('advancedBtn');
        const saveBtn = document.getElementById('saveBtn');
        const resetBtn = document.getElementById('resetBtn');
        const modalContent = document.getElementById('modalContent');

        // Inputs
        const ui = {
            maxTime: document.getElementById('cfg_max_time'),
            maxMem: document.getElementById('cfg_max_mem'),
            sanity: document.getElementById('cfg_sanity'),
            r1: document.getElementById('cfg_r1'),
            r1Start: document.getElementById('cfg_r1_start'),
            r1Step: document.getElementById('cfg_r1_step'),
            r2: document.getElementById('cfg_r2'),
            r2Start: document.getElementById('cfg_r2_start'),
            r2Step: document.getElementById('cfg_r2_step'),
            r3: document.getElementById('cfg_r3'),
            r3VStart: document.getElementById('cfg_r3_v_start'),
            r3VStep: document.getElementById('cfg_r3_v_step'),
        };

        // --- UI Logic ---

        function uiToConfig() {
            const modeRadios = document.getElementsByName('cfg_mode');
            for (const r of modeRadios) {
                if (r.checked) {
                    CONFIG.mode = r.value;
                    break;
                }
            }

            CONFIG.limits.time = parseInt(ui.maxTime.value) || 1500;
            CONFIG.limits.mem = parseInt(ui.maxMem.value) || 320;

            CONFIG.tests.sanity = ui.sanity.checked;

            CONFIG.tests.r1 = ui.r1.checked;
            CONFIG.r1.start = parseInt(ui.r1Start.value) || 11;
            CONFIG.r1.step = parseInt(ui.r1Step.value) || 1;

            CONFIG.tests.r2 = ui.r2.checked;
            CONFIG.r2.start = parseInt(ui.r2Start.value) || 100;
            CONFIG.r2.step = parseInt(ui.r2Step.value) || 100;

            CONFIG.tests.r3 = ui.r3.checked;
            CONFIG.r3.vStart = parseInt(ui.r3VStart.value) || 100;
            CONFIG.r3.vStep = parseInt(ui.r3VStep.value) || 50;
        }

        function configToUi() {
            const modeRadios = document.getElementsByName('cfg_mode');
            for (const r of modeRadios) {
                r.checked = (r.value === CONFIG.mode);
            }

            ui.maxTime.value = CONFIG.limits.time;
            ui.maxMem.value = CONFIG.limits.mem;
            ui.sanity.checked = CONFIG.tests.sanity;
            ui.r1.checked = CONFIG.tests.r1;
            ui.r1Start.value = CONFIG.r1.start;
            ui.r1Step.value = CONFIG.r1.step;
            ui.r2.checked = CONFIG.tests.r2;
            ui.r2Start.value = CONFIG.r2.start;
            ui.r2Step.value = CONFIG.r2.step;
            ui.r3.checked = CONFIG.tests.r3;
            ui.r3VStart.value = CONFIG.r3.vStart;
            ui.r3VStep.value = CONFIG.r3.vStep;
        }

        function openModal() {
            configToUi();
            modal.style.display = 'flex';
        }

        function closeModal() {
            modal.style.display = 'none';
        }

        function saveAndClose() {
            uiToConfig();
            closeModal();
            log('Settings saved.');
        }

        advancedBtn.onclick = (e) => {
            e.preventDefault();
            openModal();
        };

        saveBtn.onclick = saveAndClose;

        resetBtn.onclick = () => {
            CONFIG = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
            configToUi();
        };

        // Click outside to save and close
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                saveAndClose();
            }
        });

        // --- Benchmark Logic ---

        const resultsData = [];
        let isRunning = false;
        let stopRequested = false;

        function log(msg) {
            logEl.textContent += msg + '\n';
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }

        function addRow(name, mode, gb, diff, time, mem, status) {
            const tr = document.createElement('tr');
            if (status !== 'OK') tr.className = 'fail';
            tr.innerHTML = `<td>${name}</td><td>${mode}</td><td>${gb}</td><td>${diff}</td><td>${time}</td><td>${mem}</td><td>${status}</td>`;
            tableBody.appendChild(tr);

            const rowData = { Test: name, Mode: mode, GraphBits: gb, VDF: diff, TimeMS: time, MemoryMB: mem, Status: status };
            resultsData.push(rowData);
            console.log("Result:", rowData);
            return rowData;
        }

        function addHeader(text) {
            const tr = document.createElement('tr');
            tr.className = 'header-row';
            tr.innerHTML = `<td colspan="7">${text}</td>`;
            tableBody.appendChild(tr);
        }

        let zeno = null;
        let activeGB = 0;
        let activeMode = null; // 'WASM' or 'JS'

        async function solve(gb, diff, forceJS = false) {
            if (stopRequested) throw new Error("Stopped by user");

            const requestedMode = forceJS ? 'JS' : 'WASM';

            // Create new instance if needed (when GB decreases, first run, terminated, or mode switch)
            if (!zeno || gb < activeGB || zeno.isTerminated || activeMode !== requestedMode) {
                if (zeno) zeno.terminate();

                // Note: using explicit forceJS option
                zeno = new Zeno({
                    apiEndpoint: '/mock-api',
                    siteKey: 'benchmark-suite',
                    forceJS: forceJS
                });

                try {
                    // Warmup with appropriate mode
                    await zeno.solveInWorker({
                        generate_proof: false,
                        challenge_id: 'warmup',
                        seed: '25a86d38f9cc98ea559851e0b9dc9668692d1a7558c0e4d9774005e4cc49c01b',
                        discriminant: '91f275c1beb814026fca308b475e2bf590605d277d1d50dafbf59fba9542328aacd8f0acae2444d01866008bf2500375684ca1ae2b2afcefc8a08bc77a1220d1f560f01c2e1eaf143e9569bcfff9ac4251c90c48f74a5c8a9db70c6906ed83f11b1c071295938f1036a7d4e11d8939ebd432194418e70865cbfccd9136c70bb1ac3b40e7f7d2687bbcf524c10f46c9fad5bf8e39c85744e3494f0d5b9882b13f6bbecdad6e82459ab8546ed810c2048e38302cd95dc3ded0a7ebbeef0bfe209d9596e0065d347decb9e7eeb39d2c04cb1c1e8291a4d3e9c91169757ccf9a7d15b25fc5827144efb74c126391f18f2a0af1c7aaf86e81fad794945b9c6166f0ef',
                        vdf: 1,
                        graph_bits: 10,
                        issued_at: 0, expires_at: 0, site_key: 'bench'
                    });
                } catch (e) {
                    console.error("Warmup Failed:", e);
                }
                activeGB = gb;
                activeMode = requestedMode;
            }
            if (gb > activeGB) activeGB = gb;

            const challenge = {
                challenge_id: 'bench',
                seed: '25a86d38f9cc98ea559851e0b9dc9668692d1a7558c0e4d9774005e4cc49c01b',
                discriminant: '91f275c1beb814026fca308b475e2bf590605d277d1d50dafbf59fba9542328aacd8f0acae2444d01866008bf2500375684ca1ae2b2afcefc8a08bc77a1220d1f560f01c2e1eaf143e9569bcfff9ac4251c90c48f74a5c8a9db70c6906ed83f11b1c071295938f1036a7d4e11d8939ebd432194418e70865cbfccd9136c70bb1ac3b40e7f7d2687bbcf524c10f46c9fad5bf8e39c85744e3494f0d5b9882b13f6bbecdad6e82459ab8546ed810c2048e38302cd95dc3ded0a7ebbeef0bfe209d9596e0065d347decb9e7eeb39d2c04cb1c1e8291a4d3e9c91169757ccf9a7d15b25fc5827144efb74c126391f18f2a0af1c7aaf86e81fad794945b9c6166f0ef',
                vdf: diff,
                graph_bits: gb,
                issued_at: Date.now(),
                expires_at: Date.now() + 60000,
                site_key: 'bench'
            };

            const t0 = performance.now();
            try {
                const sol = await zeno.solveInWorker(challenge);
                const t1 = performance.now();

                // Debug: log sol object to see available fields
                console.log("Sol keys:", Object.keys(sol), "memoryUsage:", sol.memoryUsage, "memory_bytes:", sol.memory_bytes);

                // Priority: memoryUsage (set by zeno.ts from result.memory_bytes), then direct memory_bytes
                let usedMem = 0;
                if (sol.memoryUsage && sol.memoryUsage > 0) {
                    usedMem = sol.memoryUsage / 1024 / 1024;
                } else if (sol.memory_bytes && sol.memory_bytes > 0) {
                    usedMem = sol.memory_bytes / 1024 / 1024;
                }

                return { time: t1 - t0, mem: usedMem, error: null };
            } catch (e) {
                return { time: performance.now() - t0, mem: 0, error: e.message };
            }
        }

        async function runSuite() {
            tableBody.innerHTML = '';
            statusEl.textContent = "Running...";
            resultsData.length = 0;
            stopRequested = false;

            const passedGB = [];
            const wasmSuccessSet = new Set(); // Stores "gb-vdf" strings for WASM successes

            let modes = [];
            if (CONFIG.mode === 'both') modes = ['WASM', 'JS'];
            else if (CONFIG.mode === 'wasm') modes = ['WASM'];
            else if (CONFIG.mode === 'js') modes = ['JS'];

            const LIMIT_TIME_MS = CONFIG.limits.time;
            const LIMIT_MEM_MB = CONFIG.limits.mem;

            try {
                for (const mode of modes) {
                    if (stopRequested) break;

                    const isForceJS = mode === 'JS';

                    addHeader(`--- Mode: ${mode} ---`);

                    const checkWasmSuccess = (gb, vdf) => {
                        return wasmSuccessSet.has(`${gb}-${vdf}`);
                    };

                    // --- Sanity ---
                    if (CONFIG.tests.sanity && !stopRequested) {
                        log(`[${mode}] Running Sanity: GB=10, Diff=100`);
                        let res = await solve(10, 100, isForceJS);
                        addRow('Sanity', mode, 10, 100, res.time.toFixed(0), res.mem.toFixed(2), res.error || 'OK');
                        if (res.error) throw new Error("Sanity failed: " + res.error);
                        if (mode === 'WASM' && !res.error) wasmSuccessSet.add(`10-100`);
                    }

                    // --- Round 1: Graph Bits (G) ---
                    if (CONFIG.tests.r1 && !stopRequested) {
                        let gb = CONFIG.r1.start;
                        while (!stopRequested) {
                            log(`[${mode}] R1: Testing GB ${gb}...`);
                            let res = await solve(gb, 100, isForceJS);
                            const r = addRow('R1: GB Ramp', mode, gb, 100, res.time.toFixed(0), res.mem.toFixed(2), res.error || 'OK');

                            const exceeded = (res.time > LIMIT_TIME_MS || res.mem > LIMIT_MEM_MB);

                            if (!res.error && !exceeded) {
                                if (mode === 'WASM') {
                                    passedGB.push(gb);
                                    wasmSuccessSet.add(`${gb}-100`);
                                }
                            }

                            // Stop logic: Break if error OR if limits exceeded...
                            // UNLESS (Symmetry Rule): We are in JS mode AND this specific test passed in WASM.
                            // In that case, we permit it to run specifically to gather comparison data, even if slow.
                            let shouldBreak = false;

                            if (res.error) {
                                shouldBreak = true;
                            } else if (exceeded) {
                                if (mode === 'JS' && checkWasmSuccess(gb, 100)) {
                                    log(`[${mode}] R1 Limit: GB ${gb} exceeded limits but continuing (WASM parity)`);
                                    shouldBreak = false;
                                } else {
                                    log(`[${mode}] R1 Limit: GB ${gb} exceeded limits`);
                                    shouldBreak = true;
                                }
                            }

                            if (shouldBreak) break;

                            gb += CONFIG.r1.step;
                        }
                    }

                    // --- Round 2: VDF (V) ---
                    if (CONFIG.tests.r2 && !stopRequested) {
                        let diff = CONFIG.r2.start;
                        while (!stopRequested) {
                            log(`[${mode}] R2: Testing VDF ${diff}...`);
                            let res = await solve(10, diff, isForceJS);
                            const r = addRow('R2: VDF Ramp', mode, 10, diff, res.time.toFixed(0), res.mem.toFixed(2), res.error || 'OK');

                            const exceeded = (res.time > LIMIT_TIME_MS || res.mem > LIMIT_MEM_MB);

                            if (mode === 'WASM' && !res.error && !exceeded) {
                                wasmSuccessSet.add(`10-${diff}`);
                            }

                            let shouldBreak = false;

                            if (res.error) {
                                shouldBreak = true;
                            } else if (exceeded) {
                                if (mode === 'JS' && checkWasmSuccess(10, diff)) {
                                    log(`[${mode}] R2 Limit: VDF ${diff} exceeded limits but continuing (WASM parity)`);
                                    shouldBreak = false;
                                } else {
                                    log(`[${mode}] R2 Limit: VDF ${diff} exceeded limits`);
                                    shouldBreak = true;
                                }
                            }

                            if (shouldBreak) break;

                            diff += CONFIG.r2.step;
                        }
                    }

                    // --- Round 3: Combinations ---
                    if (CONFIG.tests.r3 && !stopRequested) {
                        let comboGBs = passedGB;

                        if (mode === 'JS' && comboGBs.length === 0 && CONFIG.r1.start) {
                            // Fallback if R1 didn't populate (e.g. only testing JS)
                            // Or use R1 start if available
                            comboGBs = [CONFIG.r1.start];
                        }

                        if (comboGBs.length > 0) {
                            let maxSafeVDF = Infinity;

                            for (const g of comboGBs) {
                                if (stopRequested) break;

                                let d = CONFIG.r3.vStart;

                                while (!stopRequested) {
                                    // Normally we prune if d > maxSafeVDF for previous graphs.
                                    // But for Symmetry, we might want to force it? 
                                    // Actually, standard pruning is probably fine unless the user intentionally wants full grid.
                                    // Let's stick to standard behavior but allow the loop to continue if WASM passed it.

                                    if (d > maxSafeVDF && !(mode === 'JS' && checkWasmSuccess(g, d))) {
                                        log(`[${mode}] R3: Pruning VDFs > ${maxSafeVDF} for GB=${g}`);
                                        break;
                                    }

                                    log(`[${mode}] R3: Combo GB=${g} VDF=${d}`);
                                    let res = await solve(g, d, isForceJS);
                                    const r = addRow('R3: Combo', mode, g, d, res.time.toFixed(0), res.mem.toFixed(2), res.error || 'OK');

                                    const exceeded = (res.time > LIMIT_TIME_MS || res.mem > LIMIT_MEM_MB);

                                    if (mode === 'WASM' && !res.error && !exceeded) {
                                        wasmSuccessSet.add(`${g}-${d}`);
                                    }

                                    let shouldBreak = false;

                                    if (res.error) {
                                        shouldBreak = true;
                                    } else if (exceeded) {
                                        if (mode === 'JS' && checkWasmSuccess(g, d)) {
                                            // This is key: Even if JS is super slow, if WASM did it, we show the slow result.
                                            // We do NOT break here, effectively creating a "Slow" result in the table.
                                            // However, if we don't break, we continue incrementing VDF.
                                            // If VDF=1000 took 5 seconds (WASM=0.1s), do we want to try VDF=2000? 
                                            // Probably not, unless WASM successfully did VDF=2000.

                                            // So, we Check the NEXT step. If the CURRENT step was WASM-OK, we don't break.
                                            // Actually, the loop condition is `while`.
                                            // If we `break`, we stop incrementing VDF for this GB.
                                            // We enable `shouldBreak = false` -> keep going.

                                            // We should only keep going if the *next* potential VDF is also in `wasmSuccessSet`?
                                            // Or simpler: Just rely on the checkWasmSuccess(g, d) of the *current* iteration to suppress failure?
                                            // Yes: We just survived a slow/heavy test because WASM did it.
                                            // We try the next one. If the next one WASM *didn't* do (or wasn't checked), we'll hit this block again with checkWasmSuccess=false and break.
                                            // Perfect.

                                            // But wait, maxSafeVDF logic might prune future GBs.
                                            // We should Update maxSafeVDF only if we are NOT in special parity mode.
                                            // If we are in parity mode (slow but allowed), we probably shouldn't poison maxSafeVDF for other graphs?
                                            // Actually, maxSafeVDF is usually "If GB=10 failed at VDF=5000, GB=11 will surely fail at 5000".
                                            // If GB=10 failed (but allowed), we don't want to set maxSafeVDF=5000.

                                            log(`[${mode}] R3 Limit: Combo GB=${g} VDF=${d} exceeded limits but continuing (WASM parity)`);
                                            shouldBreak = false;

                                        } else {
                                            maxSafeVDF = d;
                                            shouldBreak = true;
                                        }
                                    }

                                    if (shouldBreak) break;

                                    d += CONFIG.r3.vStep;
                                }
                            }
                        }
                    }
                } // End Mode Loop

                log("Suite Completed/Stopped.");
                statusEl.textContent = stopRequested ? "Stopped" : "Benchmark Complete";
                console.log("--- FINAL RESULTS ---");
                console.table(resultsData); // table output

            } catch (e) {
                if (e.message === "Stopped by user") {
                    log("Benchmark Stopped by User.");
                    statusEl.textContent = "Stopped";
                    console.log("--- PARTIAL RESULTS (Stopped) ---");
                    console.table(resultsData);
                } else {
                    log("Critical Error: " + e.message);
                    statusEl.textContent = "Error";
                    addRow('ERROR', '-', '-', '-', '-', '-', e.message);
                }
            } finally {
                isRunning = false;
                startBtn.textContent = "START";
                startBtn.disabled = false;
            }
        }

        startBtn.onclick = () => {
            if (isRunning) {
                stopRequested = true;
                startBtn.textContent = "STOPPING...";
                startBtn.disabled = true;
            } else {
                isRunning = true;
                startBtn.textContent = "STOP";
                runSuite();
            }
        };

        // Correct initialization
        configToUi();

    </script>
</body>

</html>